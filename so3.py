#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Dec  8 14:40:50 2020

@author: frederik

SO3 routines. Rotations are represented by a 3-d vector of scalars.
Module used to optimize time-evolution with SO3 representation, and by going to a clever rotating frame 

main
    Assuming rotation is of the form 
    
    R = R(1), where dR/d\lambda = r(\lambda) x R(\lambda),
    
    with 
    
    r(\lambda) = (1-\lambda)*rv1 + \lambda*rv2 
    
    approximates resulting rotation using the rotating frame transformation generated by 
    Q. Here Q is the frame rotating with constant angular velocity such that Q(0) = 1,
    and Q(1)rv2 is parallel with rv1. "Hamiltonian" in rotating frame is approximated by 
    its time-average over the interval.
    
    Thus,
    
    R = Q(1)*\tilde R
    
    where \tilde R is rotation by vector \theta_1 = (|rv1|+|rv2|)/2 rv1/|rv1| - \theta_2
    
    Q(1) is rotation by \theta_2
    
    And 
    
    \theta_2 = v/|v| * asin(|v|/|rv1||rv2|), with v = rv1 \times rv2
    
    returns \theta_1,\theta_2


"""

from numpy import *
from numpy.linalg import *
import numpy.random as npr
from basic import *


    
def efficient_rotate(rvd,cosnorm,sinnorm,vector):
    # nv = norm(rotation_vector,axis=-1,keepdims=1)
    # vn = rotation_vector/nv
    
    # cosnorm = # = cos(nv)
    # s = sin(nv)
    
    out = cosnorm*vector + (1-cosnorm)*rvd*sum(rvd*vector,axis=-1,keepdims=1) + sinnorm * cross(rvd,vector)
    
    return out


def rotate(rotation_vector,vector):

    nv = norm(rotation_vector,axis=-1,keepdims=1)
    vn = rotation_vector/nv

    c = cos(nv)
    s = sin(nv)


    out = c*vector + (1-c)*vn*sum(vn*vector,axis=-1,keepdims=1) +s * cross(vn,vector)
    


    return out


def convert_to_su2(vector):
    """
    convert SO(3) vector to SU(2) matrix 
    """
    a,b,c =vector
    return a*Sx + b*Sy + c * Sz

def rotating_frame_interpolator(rotation_vector,dt_vec):
    """
    Generating net rotation axis generated by time-dependent master equation
    see below for detials 
    

    Parameters
    ----------
    rv : ndarray((NT+1,NR,3)) float
        rv[nt,z,:] gives the rotation vector at step dt*nt

    dt : float
        time step. 
        
    Returns
    -------
    theta_1 : TYPE
        DESCRIPTION.
    theta_2 : TYPE
        DESCRIPTION.

 
    Details
    -------
    
    Master equation to be solved is 
    
    \partial_t v (t) = \alpha(t) x v(t)
    
    This method computes the rotation matrix at each step using the interpolation scheme
    
    R = R(1), where dR/d\lambda = r(\lambda) x R(\lambda),
    
    with R(0) = 1 and
    
    r(\lambda) = (1-\lambda)*rv1 + \lambda*rv2 
    
    Assuming rotation is of the form 
    
    R = R(1), where dR/d\lambda = r(\lambda) x R(\lambda),
    
    with 
    
    r(\lambda) = (1-\lambda)*rv1 + \lambda*rv2 
    
    approximates resulting rotation using the rotating frame transformation generated by 
    Q. Here Q is the frame rotating with constant angular velocity such that Q(0) = 1,
    and Q(1)rv2 is parallel with rv1. "Hamiltonian" in rotating frame is approximated by 
    its time-average over the interval.
    
    Thus,
    
    R = Q(1)*\tilde R
    
    where \tilde R is rotation by vector \theta_1 = (|rv1|+|rv2|)/2 rv1/|rv1| - \theta_2
    
    Q(1) is rotation by \theta_2
    
    And 
    
    \theta_2 = v/|v| * asin(|v|/|rv1||rv2|), with v = rv1 \times rv2
    
    returns \theta_1,\theta_2
    
    """
    L,S = shape(dt_vec)
    rv1 = rotation_vector[:-1]*dt_vec.reshape((L,S,1))
    rv2 = rotation_vector[1:]*dt_vec.reshape((L,S,1))
    n1 = norm(rv1,axis=-1,keepdims=1)
    n2 = norm(rv2,axis=-1,keepdims=1)
    
    v  = cross(rv1,rv2)
    nv = norm(v,axis=-1,keepdims=1)

    
    theta_2 = v/(1e-14+nv) * arcsin(nv/(n1*n2))
    
    theta_1 = 0.5*rv1/n1 * (n1+n2) - theta_2
    
    return theta_1,theta_2


def av(theta):
    return 1e-8*array((cos(theta),sin(theta),0))



if __name__=="__main__":
    
    dt    =  1/5
    omega = 2*pi
    v0 = array((1,0,0))
    v=1*v0
    for t in arange(0,1,dt):
        rv1 = av(omega*t)*dt
        rv2 = av(omega*(t+dt))*dt
        
        t1,t2 = rotating_frame_interpolator(rv1,rv2)
        v = rotate(t2,rotate(t1,v))    
        
    print(v)   
    
    r2 = av(0) - array((0,0,omega)) 
    
    v2= rotate(r2,v0)
    
    print(v2)

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    


