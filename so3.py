#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Dec  8 14:40:50 2020

@author: frederik

SO3 routines. Rotations are represented by a 3-d vector of scalars

"""

from numpy import *
from numpy.linalg import *
import numpy.random as npr
from basic import *


    


def rotate(rotation_vector,vector):
    nv = norm(rotation_vector,axis=-1,keepdims=1)
    vn = rotation_vector/nv
    
    c = cos(nv)
    s = sin(nv)
    
    out = c*vector + (1-c)*vn*sum(vn*vector,axis=-1,keepdims=1) + s * cross(vn,vector)
    
    return out


def convert_to_su2(vector):
    """
    convert SO(3) vector to SU(2) matrix 
    """
    a,b,c =vector
    return a*Sx + b*Sy + c * Sz

def rotating_frame_interpolator(rv1,rv2):
    """
    Assuming rotation is of the form 
    
    R = R(1), where dR/d\lambda = r(\lambda) x R(\lambda),
    
    with 
    
    r(\lambda) = (1-\lambda)*rv1 + \lambda*rv2 
    
    approximates resulting rotation using the rotating frame transformation generated by 
    Q. Here Q is the frame rotating with constant angular velocity such that Q(0) = 1,
    and Q(1)rv2 is parallel with rv1. "Hamiltonian" in rotating frame is approximated by 
    its time-average over the interval.
    
    Thus,
    
    R = Q(1)*\tilde R
    
    where \tilde R is rotation by vector \theta_1 = (|rv1|+|rv2|)/2 rv1/|rv1| - \theta_2
    
    Q(1) is rotation by \theta_2
    
    And 
    
    \theta_2 = v/|v| * asin(|v|/|rv1||rv2|), with v = rv1 \times rv2
    
    returns \theta_1,\theta_2
    """

    n1 = norm(rv1,axis=-1,keepdims=1)
    n2 = norm(rv2,axis=-1,keepdims=1)
    
    v  = cross(rv1,rv2)
    nv = norm(v,axis=-1,keepdims=1)

    
    theta_2 = v/(1e-14+nv) * arcsin(nv/(n1*n2))
    
    theta_1 = 0.5*rv1/n1 * (n1+n2) - theta_2
    
    return theta_1,theta_2


def av(theta):
    return 1e-8*array((cos(theta),sin(theta),0))



if __name__=="__main__":
    
    dt    =  1/5
    omega = 2*pi
    v0 = array((1,0,0))
    v=1*v0
    for t in arange(0,1,dt):
        rv1 = av(omega*t)*dt
        rv2 = av(omega*(t+dt))*dt
        
        t1,t2 = rotating_frame_interpolator(rv1,rv2)
        v = rotate(t2,rotate(t1,v))    
        
    print(v)   
    
    r2 = av(0) - array((0,0,omega)) 
    
    v2= rotate(r2,v0)
    
    print(v2)

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    


